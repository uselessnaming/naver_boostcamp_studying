# Repository 패턴
Data의 출처 상관 없이 동일한 인터페이스로 데이터에 접근할 수 있게 해주는 패턴

## 장점
1. 코드의 가독성과 유지보수성 향상
+ 데이터 접근 로직 분리: DB나 네트워크 호출 등의 데이터 접근 로직이 비즈니스 로직과 분리됨 >> 코드가 명확해진다
+ 단일 책임 원칙: 각 클래스가 자신의 역할에 집중한다. 데이터 접근 로직은 레포지터리나 데이터 소스 클래스에 집중되고, 비즈니스 로직은 서비스나 ViewModel에 집중하도록 한다

2. 데이터 소스 교체 용이
+ 유연한 데이터 소스 교체: 로컬 DB, 원격 서버, 캐시 등 다양한 데이터 소스를 쉽게 교체하거나 추가하기 쉽다
+ 의존성 주입 활용: DI 프레임 워크를 사용하면 데이터 소스를 교체할 때 Repository의 구현만 변경하면 되므로 애플리케이션의 다른 부분에는 영향을 미치지 않는다

3. 테스트 용이성
+ 독립적인 테스트: repository 패턴을 활용하면 비즈니스 로직과 데이터 접근 로직이 분리되므로 각각을 독립 테스트할 수 있다

4. 재사용성
+ 코드 재사용: 동일한 데이터 접근 로직을 여러 곳에서 사용할 수 있음. 예를 들어, 여러 ViewModel이나 서비스에서 동일한 Repository를 사용할 수 있음
+ 중앙 집중 관리: 데이터 접근 로직을 중앙에서 관리하기 때문에, 수정이 필요할 때 여러 곳을 수정할 필요 없이 Repository 클래스만 수정하면 됌

## Q interface-class를 사용하는 이유가 뭘까?
테스트 용이성이 중요한 부분이라고 생각한다      

interface로 구현하면, 구현체를 대체하기 쉽다        

```kotlin
interface ARepository{
    fun get(): Flow<Item>
}

class ARepositoryImpl: ARepository {
    override fun get(): Flow<Item>{
        return item
    }
}
```
이렇게 사용했을 때, ViewModel은 해당 Repository의 interface를 주입받았을 것이다.        
이러면 view model 테스트 시 repository에 테스트를 위한 FakeRepository를 생성하고 주입하여 테스트가 가능하다

object는 싱글톤이기 떄문에 항상 같은 인스턴스를 쓰게 되고, 이를 테스트 환경에서 교체하기는 어려울 것이다

단위 테스트의 경우에 하나의 클래스에 대한 테스트만을 권장한다        
만약 서버로부터 데이터를 받아오거나, DB에 있는 데이터를 받아오는 로직을 Repository가 처리한다고 가정해보자      
여기서 object로 처리하게 되면 해당 Repository는 서버 혹은 DB로의 연결 로직 또한 포함하게 된다       
view model 테스트에서는 이런 과정을 모두 성공한다고 가정하고 테스트를 진행해야 한다

따라서 object로 관리하게 될 경우 Test를 위한 처리를 별개로 하는 것은 불가능하다
이런 구조는 단위 테스트 시 여러 사이드 이펙트를 가져올 수 있고, 이는 View Model만 테스트하기는 어려운 구조가 된다

> 아직 학습하지는 않았지만 DI 관련해서도 object는 Kotlin/JVM에서 리플렉션 기반 Mocking을 진행해야 하므로 번거롭고, 성능이 떨어진다고 한다