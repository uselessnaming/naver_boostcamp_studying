# 내부 저장소
안드로이드 내부에 데이터를 저장하기 위해서 고민을 하고 있었다       
큰 데이터는 아니고 임시로 데이터를 저장하기 위함인데, 어떤 것을 사용할 지 모르겠어서 공부하게 되었다

> 캐싱을 위한 데이터 저장소

## RoomDB
안드로이드 내부 데이터베이스로 데이터를 관리할 수 있다      
다만 간단한 데이터를 임시적으로 처리하기 위해 도입하기에는 복잡하고 사용하는 기능에 비해 코드의 양이 비대해질 수 있다       
따라서 만약 내부적으로 저장해야 하는 데이터의 수나 양이 많아질 때 도입하면 적합할 것이라 생각한다        

## File 저장
File로 저장하는 것 또한 간단한 데이터를 저장하기 위해 사용하기 보다는 용량을 가지는 이미지, 오디오, 비디오 등을 저장할 때 사용하는 것이 유용하다.

## SharedPreferences
<details>
<summary>SharedPreferences</sumary>

[SharedPreference 공식문서](https://developer.android.com/training/data-storage/shared-preferences?hl=ko)

## 설명
간단한 데이터를 저장하기에 적합하며, Key-Value 쌍으로 데이터를 저장한다     

+ `getSharedPreferences()`: 이름으로 식별되는 공유 환경 설정 파일이 여러 개 필요한 경우 사용하게 되며 앱 모든 Context에서 이 Method를 호출할 수 있다
+ `getPreferences()`: 활동에 공유 환경 설정 파일을 하나만 사용해야 하는 경우 Activity에서 이 메소드를 사용한다

Activity 내부를 보면 SharedPreference를 가지고 있다     
따라서 간단하게 `val sharedPref = this.getSharedPreferences(STRING_KEY, Cotnext.MODE_PRIVATE)
` 로 불러와서 사용할 수 있다

이 때 사용하는 STRING_KEY 값 같은 경우는 앱에 고유하게 식별할 수 있는 이름을 사용하는 것이 좋다     

따라서 파일 이름 앞에 애플리케이션 ID를 붙여주면 좋다

## MODE
getSharedPreferences에서 사용하는 MODE의 종류는 `MODE_PRIVATE`, `MODE_WORLD_READABLE`, `MODE_WORLD_WRITEABLE`, `MODE_MULTI_PROCESS`이 있다

다만 `MODE_WORLD_READABLE`, `MODE_WORLD_WRITEABLE`의 경우에 다른 앱이 읽기 혹은 쓰기 권한으로 접근할 수 있도록 하는 옵션이었으나 보안상의 문제가 있어 API17 이후로 **Deprecated**되었다

`MODE_MULTI_PROCESS`의 경우에는 여러 프로세스에서 하나의 SharedPreference를 접근할 수 있도록 하는 옵션이었지만 이는 동기화 문제가 있어서 API23 이후로 **Deprecated**되었다

## 쓰기
SharedPreference 객체를 불러와 `edit()`함수를 통해 수정하게 된다        
`apply()`와 `commit()`으로 수정을 완료할 수 있다        
`apply()`를 사용하게 된다면 동기적으로 SharedPreference 객체를 갱신하지만 디스크에는 비동기적으로 작성한다      
`commit()`은 디스크 또한 동기적으로 작성하지만, 이 `commit()` 호출은 MainThraed를 block할 수 있기 때문에 호출의 위치를 주의해야 한다

데이터는 XML로 저장된다

## 읽기
저장했던 type에 따라서 getXXX() 함수로 받아오면 된다

## migration
공식문서를 살펴보면 DataStore는 SharedPreference의 많은 단점을 극복했기 떄문에 이전하는 것을 권고하고 있습니다

### 단점
+ SharedPreferences에서는 PrimitivesType만을 관리한다 (따라서 별도의 Type을 사용할 수 없다)
+ SharedPreferences를 이용한 데이터는 루팅을 통해 정보가 쉽게 보여진다고 한다. 난독화를 할 수는 있으나 가독화를 통해 쉽게 데이터를 가져올 수 있다고 한다.
> 루팅: 안드로이드 OS에서 최상위 권한인 루트 권한을 얻어 해당 기기에 제약을 풀어버리는 행위
+ UiThread에서 호출이 안전하지 않다.
+ 비동기 API에 대한 대응 또한 부족하다

### 단점에 대한 대응
이런 취약점에 대응하기 위해 KeyStore가 공개되었다       
난독화, 가독화를 위해서는 Key가 필요한데 이 Key를 기기의 Container에 저장하여 기기에서 Key 추출을 어렵게 만드는 방법이다        
Key를 활용하여 정보를 난독화하고, 이 Key에 대한 접근을 어렵게 만들어 보안 취약점을 보완한 것이다        

따라서 SharedPreferences를 활용해야 한다면 필수적으로 KeyStore 처리를 해야 한다고 한다

</details>

## DataStore
<details>
<summary>DataStore</summary>

DataStore는 위에서 보이는 SharedPreferences의 단점을 보완하기 위해서 개발되었다

[DataStore 공식문서](https://developer.android.com/topic/libraries/architecture/datastore?hl=ko#prefs-vs-proto)

## 주의 사항
+ 동일한 프로세스에서 특정 파일의 `DataStore`인스턴스를 두 개 이상 만들지 않는다        
만약 만들게 되면 데이터를 읽거나 쓸 때 `IllegalStateException`을 발생시킨다

+ `DataStore<T>`의 일반 유형은 변경 불가능해야 한다
DataStore에서 사용되는 유형을 변경하게 되면 DataStore가 제공하는 모든 보장이 무효되고, 잠재적으로 심각하고 포착하기 어려운 버그가 발생할 수 있다

+ 동일한 파일에서 `SingleProcessDataStore`와 `MultiProcessDataStore`를 함께 사용하지 않는다     
만약 둘 이상의 프로세스에서 사용하려고 한다면 항상 `MultiProcessDataStore`를 사용하도록 한다

## PreferencesDataStore
SharedPreferences를 대체한다        
key-value로 데이터를 저장하게 된다      
사전 정의된 스키마를 필요로 하지는 않지만 그렇기 때문에 TypeSafty 보장이 되지 않는다

## ProtoDataStore
맞춤 데이터 유형의 인스턴스로 데이터를 저장한다     
이 구현은 TypeSafety를 보장하며, 이를 위해 ProtocolBuffer를 사용해 스키마를 정의해야 한다

</details>