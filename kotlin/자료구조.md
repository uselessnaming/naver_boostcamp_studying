# 자료 구조
## Stack
**LIFO(Last-In-First-Out)** 구조        
즉 나중에 추가한 것을 먼저 내보내는 구조이다        

Kotlin에서 Stack을 구현한 클래스가 존재한다.        
이는 java.utils 패키지의 Stack 클래스를 사용하는 것으로, Stack 은 내부적으로 Vector 클래스를 사용한다.
이는 비효율적인 구조이다.

Deque 인터페이스를 구현하는 ArrayDeque를 사용하면 효율적으로 Stack을 사용할 수 있다.     

### Stack 내부 구조
Stack 내부에서는 Array<Vector>를 구현한다.
그렇기 때문에 초기 사이즈가 있고, Stack에 값이 계속 추가되어 한계치에 도달하면 사이즈를 늘려 복사하는 방식을 취한다

따라서 데이터가 M개 있다면 최악의 경우 O(M)의 시간 복잡도로 값이 추가될 수 있다     
또한 이후에 추가될 값을 위해 불필요 메모리 공간을 이미 점유하는 문제가 있다     

대신 Array로 되어 있으므로 메모리를 효율적으로 사용이 가능하다

**그러면 왜 이것이 있는가?**        
예전 Java1.2 미만에서는 Vector만이 존재했고, LinkedList가 소개된 것은 Java1.2이기 떄문에 처음 Stack을 구현할 때 Vector로 구현했던 프로젝트들이 많았기에 아직 유지하고 있는 것

### 코틀린 Stack 구현
Kotlin에서는 `Deque<Int>`를 사용하는 것을 권장한다      
ArrayDeque는 내부적으로 LinkedList를 사용하지는 않지만, Stack 자료 구조를 만들기 위해 더욱 효율적으로 Array를 사용할 수 있도록 구현되어 있다

ArrayDeque 내부를 보면 resizable circular array를 활용해 Deque를 구현한다       
이는 배열의 처음과 끝이 연결된 구조를 가지기 떄문에 맨 마지막에 추가 요소를 넣을 때, 공간이 없다면 무조건 사이즈를 증가시키는 것에 대한 문제점을 해결했다       

### 정리
이는 Stack 만을 사용하는 사람에게 효율적이지는 않은 구조이다        
보통 Stack을 사용하는 이유는 위에 값을 넣고 빼는 데 의미가 있기 때문이다        

그리고 여전히 크기가 아무리 늘어나도 전체 복사가 일어나지 않는 Doubly LinkedList에 비해 한계가 명확하다

## Queue
**FIFO(First-In-First-Out)** 구조       
먼저 추가한 것이 먼저 나가는 구조

## Tree
노드들이 나무 가지처럼 연결된 **계층적 자료구조**     

* 노드: 트리들을 구성하는 기본 요소       
* 간선: 노드와 노드 간의 연결
* 루트 노드: 부모가 없는 최상위 노드
* 부모 노드: 자식 노드를 가진 노드
* 자식 노드: 부모 노드의 하위 노드
* 깊이: 루트에서 어떤 노드까지의 간선 수
* 높이: 노드들 중 가장 큰 깊이 값
* Degree: 해당 노드의 자식 수

## Map
**Key-Value**를 사용한 자료 구조      
Key를 통해 Value를 얻게 되고, Key는 고유한 값을 가진다      
Map은 저장 순서는 따로 중요하게 생각하지는 않는다(key로 value를 찾는 구조이기 때문에)

## Graph
**정점과 간선**으로 이뤄진 자료구조     
정점들의 관계를 간선으로 구성하는 조직도이다        

즉 트리도 일종의 그래프가 될 수 있지만, 그래프에서는 부모, 자식 노드의 개념이 없다      