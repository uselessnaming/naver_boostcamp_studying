# 함수형 인터페이스
추상 Method가 하나 뿐인 Interface를 함수형 인터페이스 혹은 SAM(Single Abstract Method) Interface라 부른다

함수형 인터페이스에서 여러 비추상 Method는 존재할 수 있으나 추상 Method는 하나만이 존재할 수 있다

```kotlin
fun interface Runnable{
    fun invoke()
}
```

위와 같은 형태가 바로 함수형 인터페이스의 구조이다

함수형 인터페이스는 람다식을 활용해 SAM 변환을 사용할 수 있다

위의 Runnable을 예로 들었을 떄, 기본적으로 SAM 변환 사용 없이 구현한다면

```kotlin
val runnable = object: Runnable{
    override fun invoke() {
        Log.d(TAG, "runnable")
        return
    }
}
```
이렇게 구현해야 한다

다만 SAM 변환을 적용시키면 

```kotlin
val runnable = Runnable{ Log.d(TAG, "runnable") }
```
이렇게 구현할 수 있다

이를 사용할 떄 역시
```kotlin
runnable.invoke()
```
와 같이 간편하게 사용할 수 있다

## 장점
+ 보일러 코드를 줄일 수 있다
+ 가독성이 크게 향상된다
+ 타입 추론 또한 컴파일러가 자동으로 할 수 있게 되고, 명시적으로 타입을 선언할 필요가 없어진다
+ 람다를 활용하는 방식이므로 특정 코드 블록을 전달하는 것으로 호출 시점에서만 사용하도록 지연시킬 수 있다

## 결론
책임 분리를 진행하다보면 함수형 인터페이스가 생기기 마련이다        
이 때는 망설이지 말고 함수형 인터페이스를 구현해서 더 효율적으로 구현하자