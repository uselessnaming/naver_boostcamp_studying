# Parcelable VS. Serializable
Serializable과 Parcelable 모두 Android에서 객체를 직렬화하여 다른 액티비티나 서비스로 전달할 때 사용하는 것

## Serializable
Java의 표준 직렬화 방식으로 Android에서 사용이 가능
특별한 메소드 구현을 요구하지 않는 인터페이스이며, 객체가 이 인터페이스를 구현하면 Java의 기본 직렬화를 사용할 수 있다

#### 장점

구현하기 매우 쉽고 간편함
복잡한 계층 구조를 가진 객체도 쉽게 직렬화할 수 있다

#### 단점

비교적 느린 성능을 가지고 있고, Reflection을 사용하기 때문에 속도가 느리고 메모리 할당이 많다
> Reflection은 객체를 검사하고 조작하는 메커니즘으로 프로그램 실행 중 객체를 동적으로 조작할 수 있는 기능

**Reflection은 왜 느릴까?**      
Reflection은 런타임에 클래스 정보를 조회하고, 메소드나 필드를 동적으로 호출할 수 있게 해주는 API이다.
이 때 런타임 시 처리되기 때문에, 일반적인 메소드보다 추가적인 오버헤드가 발생한다      
즉 이런 동적 접근 자체가 느리도록 만드는 주 요인이라고 할 수 있다      

직렬화된 파일 크기가 상대적으로 크고, 직렬화 과정에서 객체가 변경되면 InvalidClassException 이 발생할 수 있다
> 이를 해결하기 위해서 serialVersionUID를 관리해야 한다

Serizliable은 일반적으로 Parcelable보다 느리다

이것을 극복하기 위해서 직렬화 프로세스를 사용자가 직접 커스텀으로 구현한 방식으로 수정하면 Java의 자동 직렬화 프로세스를 통한 많은 메모리 할당을 줄일 수 있다     
[이 링크](https://github.com/GMLim/Android-Serialization-Test?source=post_page-----bc2b9a7ba810--------------------------------)에서 해당 예시를 볼 수 있다       

## Parcelable
Android에 특화된 직렬화 방식으로 Google에서 Android의 성능을 위해 설계하였다        
Parcelable 인터페이스에 구현하기 위해 writeToParcel(), describeContents()와 같은 메소드를 직접 구현해야 하는 번거로움이 있다      
CREATOR라는 정적 필드를 사용하여 복구 로직을 정의해야 함     

**장점**

Android에서 시스템 직렬화와 역직렬화의 성능을 최적화하여, Serializable보다 훨씬 빠르고 메모리 효율적

**단점**

복잡하고 까다로운 구현과 수동으로 직렬화와 객체를 복원하는 코드를 작성해야 한다
복잡한 계층 구조의 객체를 직렬화하기 어렵다
모든 객체가 Parcelable을 구현해야 하기 때문에, 다른 라이브러리나 코드에 의존하는 객체는 직렬화가 불가능하다

Parcelable은 복잡하고 구현이 까다롭다는 단점이 있다
하지만 안드로이드 공식 문서를 살펴보면 Parcelize어노테이션을 활용해 번거로운 작업을 넘어갈 수 있다
이를 통해 복잡한 구현을 단순화하고, 수동으로 작성할 때 발생하는 실수를 줄일 수 있게 된다