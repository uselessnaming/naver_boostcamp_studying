# naver_boostcamp_studying
네부캠 과정의 학습 내용 정리 repository

## 1주차
<details>
<summary>1주차 학습 정리</summary>

+ [ActivityLifecycle](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/ActivityLifecycle.md)
+ [Button Events](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Button%20Events.md)
+ [Custom View 생성 과정](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Custom%20View%20%EC%83%9D%EC%84%B1%20%EC%A0%95%EB%A6%AC.md)
+ [Fragment](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Fragment.md)
+ [Layout](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Layout.md)
+ [Parcelable vs Serializable](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/Parcelable%20vs%20Serializable.md)
+ [Service](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Service.md)
+ [Intent 정리](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/intent%20%EC%A0%95%EB%A6%AC.md)
</details>

## 2주차
<details>
<summary>2주차 학습 정리</summary>

## Compose
+ [@Composable](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/%40Composable.md)
+ [Composable 수명 주기](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Composable%20%EC%88%98%EB%AA%85%20%EC%A3%BC%EA%B8%B0.md)
+ [Compose 단계](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Compose%20%EB%8B%A8%EA%B3%84.md)
+ [Dynamic Color](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Dynamic%20Color.md)
+ [Jetpack Compose](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Jetpack%20Compose.md)
+ [LazyColumn, LazyRow](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/LazyRow%2C%20LazyColumn.md)
+ [Material Theme](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/MaterialTheme.md)
+ [Modifier](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Modifier.md)
+ [Navigation Drawer](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Navigation%20Drawer.md)
+ [Navigation Rail](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Navigation%20Rail.md)
+ [Navigation2](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Navigation2.md)
+ [Navigation3](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Navigation3.md)
+ [Remember vs RememberSaveable](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Remember%EA%B3%BC%20RememberSaveable.md)
+ [Scaffold](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Scaffold.md)
+ [Surface](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Surface.md)
+ [TextField](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/TextField.md)
+ [UDF 패턴](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/UDF%20%ED%8C%A8%ED%84%B4.md)
+ [Remember vs MutableState](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/remember%EA%B3%BC%20mutable%20state.md)
+ [Vector Resource vs Painter Resource](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/vectorResource%20vs%20painterResource.md)
+ [Material Theme 색상](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/Material%20Theme%20%EC%83%89%EC%83%81.md)

## android
+ [SVG vs PNG](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/Svg%20vs%20Png.md)

## Annotation
+ [OptIn](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/annotation/OptIn.md)
+ [Res](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/annotation/Res.md)

## error
+ [cant be saved using the current SaveableStateRegistry](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/error/cannot%20be%20saved%20using%20the%20current%20SaveableStateRegistry.md)

## kotlin
+ [inline 함수](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/Inline%20%ED%95%A8%EC%88%98.md)
+ [함수 호출 vs 함수 참조](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/%EC%A0%90%20%EC%97%B0%EC%82%B0%20vs%20%EB%8D%94%EB%B8%94%20%EC%BD%9C%EB%A1%A0%20%EC%97%B0%EC%82%B0.md)

## warning
+ [Property will not be serialized into a 'Parcel'](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/warning/Property%20will%20not%20be%20serialized%20into%20a%20'Parcel'.md)

</details>

## 3주차
<details>
<summary>3주차 학습 정리</summary>

## Jetpack Compsoe
+ [MaterialTheme 추가 학습](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/MaterialTheme.md)

## android
+ [Flow와 LiveData 학습](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/LiveData%20vs%20Flow.md)
+ [target sdk 버전과 compile sdk 버전](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/targetSdk%20VS%20compileSdk.md)

## kotlin
+ [inline 함수를 왜 row, column에서 사용하는 가에 대한 대답](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/Inline%20%ED%95%A8%EC%88%98.md)

</details>

## 4주차
<details>
<summary>4주차 학습 정리</summary>

## 추가 학습 자료
+ [클린 코딩 발표 자료](https://docs.google.com/presentation/d/16c7_CkJO-lT2P0jbUG-NfM2ty9vGstteswGBqKFtA7o/edit?slide=id.g261f0782c07_0_0#slide=id.g261f0782c07_0_0)

## Jetpack Compose
+ [State-base TextField](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/TextField.md)
> State-Base TextField를 사용하면 커서 위치와 같은 세세한 조작을 할 수 있다

+ [debounce](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/debounce.md)
> 마지막 이벤트 발생 이후, 일정 시간 동안 추가로 발생하는 이벤트가 없다면 마지막으로 발생한 이벤트를 방출한다

+ [snapshot flow](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/Jetpack%20Compose/snapshot%20flow.md)
> UI 상태에 따른 비동기 작업을 연결할 때 사용한다
> Snapshot의 상태 변화를 Flow로 관찰할 때 사용

## XML
+ [Fragment lifecycle 및 주의 사항 보충](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Fragment.md)
> Fragment에서는 Fragment와 Fragment View 생명주기가 별도로 존재한다
> Fragment에서 binding을 null로 초기화 하고, onCreateView에서는 할당, onDestroyView에서는 제거하는 방식을 통해 GC가 수집해갈 수 있도록 한다

+ [Fragment Binding 관련 중복 코드 개선](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/Fragment%20binding%20%ED%95%A0%EB%8B%B9%20%EC%A4%91%EB%B3%B5%20%EC%BD%94%EB%93%9C%20%EA%B0%9C%EC%84%A0.md)
> Fragment에서 binding할 때마다 중복적으로 발생하는 코드를 개선하기 위한 방안
> 1. BaseFragment 정의
> 2. AutoClearedValue 클래스 정의
> 3. 외부 라이브러리 활

## Android
+ [Activity Result Contracts](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/ActivityResultContracts.md)
> Intent를 기반의 작업이나 권한 요청 등 여러 작업을 간단하고 안전하게 처리할 수 있도록 도와주는 API

+ [아키텍처](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/architecture.md)
> 기본적으로 UI Layer와 Data Layer로 구분
> UI Layer: 앱 데이터를 보여주는 UI와 상태를 관리하는 State Holder로 구성
> Data Layer: 앱 데이터를 관리하며, 앱 전역에 데이터를 나눠

+ [JAVA URI와 Adnroid Uri](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/URI%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.md)
> Java는 Serializable을 상속, 안드로이드는 Parcelabel을 상속
> Data Layer에서는 순수 코틀린으로 동작하는 데 안드로이드에 종속되어 있는 Uri를 사용하면 단위 테스트에서 Mocking 작업이 별도로 필요해 번거롭다

## Design Pattern
+ [Observer 패턴](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/design%20pattern/%EC%98%B5%EC%A0%80%EB%B2%84%20%ED%8C%A8%ED%84%B4.md)
> 하나의 대상에 대해 하나 혹은 그 이상의 관찰자를 두는 패턴
> 대상에서 발생한 이벤트를 관찰자가 처리한다
> 대상의 상태 변화를 여러 관찰자에게 알려, 객체 간의 결합도를 낮춰주기 위한 패턴

+ [Repository 패턴](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/design%20pattern/Repository%20%ED%8C%A8%ED%84%B4.md)
> Data 출처와 상관없이 동일한 인터페이스로 접근할 수 있도록 하는 패턴

+ [Facade 패턴](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/design%20pattern/Facade%20%ED%8C%A8%ED%84%B4.md)
> 복잡한 클래스들의 관계를 인터페이스로 추상화하여 내부 동작을 몰라도 사용할 수 있도록 하는 디자인 패턴
> 집약화하기 위한 패

## Kotlin
+ [자료 구조 - Stack](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0.md)
> Stack을 구성할 때 Deque 인터페이스를 구현하는 ArrayDeque을 사용한다
> Array<Vector>로 구성된 Stack은 Deque보다 비효율적
> ArrayDeque는 resizable circular array로 마지막 요소 추가 시 앞 자리를 확인하여 있다면 앞에다가 데이터를 추가하는 방식으로 효율성을 늘렸다

+ [Array vs List](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/Array%20vs%20List.md)
> Array는 메모리 구조상 연속적, List는 비연속적
> Array는 요소 접근이 빠름, List는 포인터 구조로 되어있어 느림
> Array는 삭제 삽입이 느림, List는 삽입 삭제가 빠름름

</details>

## 5주차
<details>
<summary>5주차 학습 정리</summary>

## CS
+ [REST API](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/CS/REST%20API.md)
> HTTP 메소드(행위)와 자원(URI), 그리고 표현으록 구성    
> 특징: Uniform, Stateless, Caching, Self-descriptiveness, Client-Server, 계층형 구조    

+ [URI vs URL](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/CS/URI%20vs%20URL.md)
> URI는 Uniform Resource Identifier, URL은 Uniform Resource Location    
> URI는 리소스에 대한 식별자, URL은 리소스에 대한 위치 식별자    
> URI가 URL보다 더 큰 범    

## XML
+ [FrameLayout](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/FrameLayout.md)    
> 여러 개의 자식들을 추가할 수는 있으나, 순차적으로 Stack처럼 쌓임    
> 보통 하나의 뷰를 교체해서 사용하는 식으로 사용한다    

## Android
+ [LiveData](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/LiveData.md)
> 관찰 가능한 데이터 홀더 클래스 / lifecycle을 인식한다    
> LiveData에 대한 옵저버를 등록하고, LiveData의 값이 변경된다면 구독하고 있는 observer들에게 이를 알린다. observer들은 이 이벤트를 처리한다    
> Observer는 어떤 lifecycle에 결합되어 있으며, `STARTED` 혹은 `RESUMED` 상태일때만 활성 상태로 간주하며 알림을 받는다    

+ [Network Library](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/Network%20%EC%97%B0%EA%B2%B0%20%EB%9D%BC%EC%9D%B4%EB%B8%8C%EB%9F%AC%EB%A6%AC.md)
> HttpUrlConnection 클래스 사용    
>> URL 마다 openConenction 명령으로 연결을 해야 한다    
>> timeout 등 세세한 설정을 다 해줘야 한다    
> Retrofit 클래스 사용    
>> 내부적인 동작을 자동적으로 넘겨준다    
>> Interceptor를 활용해 공통 헤더를 넘길 수 있다    
>> 한 번 생성하면 해당 URL을 기반으로 연결되는 처리를 계속 할 수 있다    
>> 좀 더 직관적이다    

+ [ViewModel에서 init 블록을 사용한 상태 초기화](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/ViewModel%20init%20%EB%B8%94%EB%A1%9D.md)
> ViewModel 생성 자체와 강한 응집도를 갖는다    
> 따라서 기능 단위 테스트 코드 작성이 어려워진다    
> **On-demand Observing**을 활용하여 내가 데이터가 필요할 때 데이터를 수집하거나 관찰하는 것으로 해결하자    

## Design Pattern
+ [Adapter 패턴](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/design%20pattern/Adapter%20%ED%8C%A8%ED%84%B4.md)
> Adapter 패턴은 관리를 위임하는 것이다    
> A 클래스와 B 클래스가 있을 때 A 클래스가 Adapter 클래스를 통해서 B 클래스를 조작하게 된다    
> 따라서 A 클래스는 B 클래스와 관련된 것을 모두 모르고, Adapter 클래스의 동작만을 알게 되어 Adapter 클래스의 동작만 호출하는 방식이    
</details>

## 6주차
<details>
<summary>6주차 학습 정리</summary>

### CS
+ [프롬프트 엔지니어링](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/CS/%ED%94%84%EB%A1%AC%ED%94%84%ED%8A%B8%20%EC%97%94%EC%A7%80%EB%8B%88%EC%96%B4%EB%A7%81.md)     
> AI에게 효율적인 답을 얻기 위해 사용하는 방법      
> Zero-shot, Few-shot, Chain-of-Thought 방법이 존재한다

### XML
+ [DialogFragment](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/DialogFragment.md)       
> Dialog를 생성하고 호스팅하도록 설계된 Fragment        
> FragmentManager가 백스택을 관리하여 Configuration Change에서도 안전하다       
> 또한 복합적인 UI 구성에도 유리하다

+ [ViewBinding](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/XML/ViewBinding.md)     
> android에서 res/layout 폴더의 xml에 대해서 자동적으로 binding을 생성해주는 기능

### android
+ [LiveData](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/android/LiveData.md)       
> Lifecycle을 인식하는 관측 가능한 데이터 Holder        
> 관찰자가 active 상태일 때만 데이터 변동을 알려준다        
> 메모리 누수 없음
> 최신 데이터 유지
> 수명 주기를 수동으로 처리하지 않음

### Kotlin
+ [시간을 나타내는 class](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/%EC%8B%9C%EA%B0%84%EC%9D%84%20%EB%82%98%ED%83%80%EB%82%B4%EB%8A%94%20class.md)     
> LocalDateTime은 그저 시간의 정보만        
> OffsetDataTime은 GMT를 기준으로 한 시차 계산 포함 (GMT는 경도 0을 기준으로 한 지구의 시간대 계산)     
> ZonedDataTime은 지역 정보까지 포함

+ [Backing Field와 Property](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/Backing%20Field%EC%99%80%20Property.md)     
> Backing Property를 활용하면 컴파일 시 더 효율적인 코드를 생성할 수 있다       
> `get() = _a`와 `a = _a`는 다른 코드를 생성한다

+ [함수형 인터페이스](https://github.com/uselessnaming/naver_boostcamp_studying/blob/main/kotlin/%ED%95%A8%EC%88%98%ED%98%95%20%EC%9D%B8%ED%84%B0%ED%8E%98%EC%9D%B4%EC%8A%A4.md)        
> 추상 Method가 하나인 interface        
> 람다를 통해 바로 할당이 가능      
> 호출 또한 직접 접근하여 사용할 수 있다        
> 보일러 코드 최소화, 람다 사용

</details>